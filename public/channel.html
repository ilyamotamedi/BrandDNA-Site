<!DOCTYPE html>
<html lang="en">
<head>
    <script src="config.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Channel DNA</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Unbounded:wght@200..900&display=swap">
    <link rel="stylesheet" href="styles.css">
    <script src="nav-template.js"></script>
    <style>
        .channel-link {
            text-decoration: none;
            color: inherit;
            position: relative;
            display: inline-block;
            transition: color 0.2s ease;
        }

        .channel-link:hover {
            color: #F742BD;
        }

        .channel-link .arrow {
            margin-left: 4px;
            font-size: 0.9em;
        }

        .channel-link .underline {
            position: absolute;
            left: 0;
            right: 0;
            bottom: -2px;
            height: 2px;
            background: radial-gradient(circle at center, #F53151 0%, #F742BD 100%);
            transform: scaleX(0);
            transition: transform 0.2s ease;
            transform-origin: left;
        }

        .channel-link:hover .underline {
            transform: scaleX(1);
        }

        .dna-buttons-container {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 2rem;
            margin-bottom: 2rem;
        }

        .edit-dna-btn,
        .reprompt-dna-btn {
            padding: 0.8rem 1.5rem;
            color: white;
            border: none;
            border-radius: 24px;
            font-family: 'Unbounded', sans-serif;
            font-weight: 500;
            cursor: pointer;
            white-space: nowrap;
            background: radial-gradient(circle at center, #F53151 0%, #F742BD 100%);
            position: relative;
            min-width: 120px;
            transition: opacity 0.2s ease;
        }

        .edit-dna-btn::before,
        .reprompt-dna-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 24px;
            box-shadow: inset 0 0 15px #FDB5E3;
            pointer-events: none;
        }

        .edit-dna-btn:hover,
        .reprompt-dna-btn:hover {
            opacity: 0.9;
        }

        .brand-card-body[contenteditable="true"] {
            padding: 1rem;
            background-color: rgba(0, 0, 0, 0.02);
            border-radius: 8px;
            outline: none;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        /* Add to your styles.css */
.overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 1000;
}

.overlay-content {
    background: white;
    padding: 2rem;
    border-radius: 16px;
    width: 90%;
    max-width: 600px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
}

.overlay-title {
    font-size: 1.2rem;
    margin-bottom: 1.5rem;
    color: #26201F;
}

.feedback-textarea {
    width: 100%;
    min-height: 150px;
    padding: 1rem;
    border: 1px solid #ddd;
    border-radius: 8px;
    font-family: 'Unbounded', sans-serif;
    font-size: 0.9rem;
    margin-bottom: 1.5rem;
    resize: vertical;
}

.overlay-buttons {
    display: flex;
    gap: 1rem;
    justify-content: flex-end;
}

.subscriber-count {
    margin-bottom: 0.5rem; /* Adds space below the subscriber count */
    font-size: 0.9rem;
    color: #26201F;
}

.channel-description {
    font-size: 0.9rem;
    color: #26201F;
    opacity: 0.8;
    overflow: hidden;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    line-clamp: 2;
    -webkit-box-orient: vertical;
}
    </style>
</head>
<body>
    <div class="container">
        <div id="nav-placeholder"></div>
        <main class="content">
            <div class="search-container">
                <div class="search-box">
                    <input type="text" placeholder="Creator name" class="brand-input" oninput="debounceChannelSearch(event)" data-translation-key="channel-placeholder">
                    <div class="search-icons">
                        <img src="/icons/add.svg" alt="Add Files" class="plus-icon-svg" onclick="document.getElementById('fileInput').click()">
                        <img src="/icons/drop_down.svg" alt="Dropdown" class="dropdown-arrow">
                    </div>
                    <input type="file" id="fileInput" class="file-input" multiple onchange="handleFileSelect(event)">
                    <input type="file" id="csvFileInput" accept=".csv" style="display: none;" onchange="handleCsvFileSelect(event)">
                    <div class="dropdown-menu" id="channelsDropdown"></div>
                </div>
                <button class="get-dna-btn" onclick="getChannelDNA()" data-translation-key="channel-get-dna-button">GET DNA</button>
                <button class="get-dna-btn" onclick="uploadChannelDNAs()" data-translation-key="channel-upload-dnas-button">UPLOAD DNAS</button>
            </div>
            <div class="file-list" id="fileList"></div>
            <div id="channel-preview" style="max-width: 600px; width: 100%; margin: 1rem auto; display: none;">
                <div style="display: flex; align-items: center; background: white; padding: 1.5rem; border-radius: 16px; box-shadow: 0 2px 8px rgba(0,0,0,0.05);">
                    <img id="preview-thumbnail" alt="Channel thumbnail" style="width: 80px; height: 80px; border-radius: 50%; margin-right: 1.5rem; object-fit: cover;">
                    <div>
                        <h3 id="preview-title" style="margin: 0 0 0.5rem 0; font-size: 1.1rem; color: #26201F;">
                            <a id="preview-link" href="" target="_blank" style="text-decoration: none; color: inherit; position: relative;">
                                <span id="preview-name"></span>
                                <span style="margin-left: 4px; font-size: 0.9em;">↗</span>
                                <span style="position: absolute; left: 0; right: 0; bottom: -2px; height: 2px; background: radial-gradient(circle at center, #F53151 0%, #F742BD 100%); transform: scaleX(0); transition: transform 0.2s ease; transform-origin: left;"></span>
                            </a>
                        </h3>
                        <p id="preview-description" style="margin: 0; font-size: 0.9rem; color: #26201F; opacity: 0.8; overflow: hidden; display: -webkit-box; -webkit-line-clamp: 2; line-clamp: 2; -webkit-box-orient: vertical;"></p>
                    </div>
                </div>
            </div>
            <div class="loading-container" style="margin-top: 3rem;">
                <div class="loading-spinner"></div>
                <div class="loading-text">generating...</div>
            </div>
            <div class="channel-results" style="max-width: 600px; width: 100%; margin: 3rem auto;"></div>
        </main>
    </div>

    <div class="overlay" id="repromptOverlay">
        <div class="overlay-content">
            <h3 class="overlay-title">What would you like to adjust about the DNA?</h3>
            <textarea class="feedback-textarea" placeholder="Enter your feedback here..."></textarea>
            <div class="overlay-buttons">
                <button class="get-dna-btn" onclick="cancelReprompt()">CANCEL</button>
                <button class="get-dna-btn" onclick="regenerateDNA()">REGENERATE DNA</button>
            </div>
        </div>
    </div>

    <script>
        // Store channel details globally
        let currentChannelDetails = null;
        let selectedFiles = new Set();
        let API_KEY = 'AIzaSyCn-POpcBdtSgoS1c8TBLNbZJkw3cUBmM8'; // BrandDNA Key - AIzaSyDwFkoH0_iCXFy559_HKveTlZYWEjUhXGQ - DreamTeam Video - AIzaSyCn-POpcBdtSgoS1c8TBLNbZJkw3cUBmM8
        const CHANNELS_URL = 'https://www.googleapis.com/youtube/v3/channels';
        const PLAYLIST_ITEMS_URL = 'https://www.googleapis.com/youtube/v3/playlistItems';
        const NUM_VIDEOS = 3;
    

        function handleFileSelect(event) {
            const files = event.target.files;
            const fileList = document.getElementById('fileList');
            
            for (const file of files) {
                if (!selectedFiles.has(file.name)) {
                    selectedFiles.add(file.name);
                    const fileItem = document.createElement('div');
                    fileItem.className = 'file-item';
                    fileItem.innerHTML = `
                        <span>${file.name}</span>
                        <span class="remove-file" onclick="removeFile('${file.name}')">×</span>
                    `;
                    fileList.appendChild(fileItem);
                }
            }
        }

        function removeFile(fileName) {
            selectedFiles.delete(fileName);
            const fileList = document.getElementById('fileList');
            const fileItems = fileList.getElementsByClassName('file-item');
            for (const item of Array.from(fileItems)) {
                if (item.firstElementChild.textContent === fileName) {
                    fileList.removeChild(item);
                    break;
                }
            }
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        const debounceChannelSearch = debounce(async (event) => {
            const query = event.target.value.trim();
            const previewElement = document.getElementById('channel-preview');
            const previewImage = document.getElementById('preview-thumbnail');
            const previewTitle = document.getElementById('preview-title');
            const previewDescription = document.getElementById('preview-description');

            if (query.length < 2) {
                previewElement.style.display = 'none';
                currentChannelDetails = null;
                return;
            }

            try {
                // First search for the channel ID
                const searchUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&type=channel&q=${encodeURIComponent(query)}&key=${API_KEY}`;
                const searchResponse = await fetch(searchUrl);
                const searchData = await searchResponse.json();

                if (searchData.items && searchData.items.length > 0) {
                    // Get the channel ID from search results
                    const channelId = searchData.items[0].id.channelId;
                    const channelUrl = `https://www.youtube.com/channel/${channelId}`;

                    // Then get the full channel details, INCLUDING STATISTICS
                    const channelDetailsUrl = `${CHANNELS_URL}?part=snippet,statistics&id=${channelId}&key=${API_KEY}`;
                    const channelResponse = await fetch(channelDetailsUrl);
                    const channelData = await channelResponse.json();

                    if (channelData.items && channelData.items.length > 0) {
                        const channel = channelData.items[0].snippet;
                        const statistics = channelData.items[0].statistics;
                        // Store channel details
                        currentChannelDetails = {
                            id: channelId, // Add channel ID for consistent use
                            name: channel.title,
                            thumbnail: channel.thumbnails.medium.url,
                            description: channel.description,
                            channelUrl: channelUrl,
                            subscriberCount: statistics.subscriberCount
                        };

                        // Update preview
                        previewImage.src = `/proxy-image?url=${encodeURIComponent(currentChannelDetails.thumbnail)}`;
                        previewTitle.innerHTML = `
                            <a href="${currentChannelDetails.channelUrl}" target="_blank" class="channel-link">
                                <span id="preview-name">${currentChannelDetails.name}</span>
                                <span class="arrow">↗</span>
                                <span class="underline"></span>
                            </a>
                        `;

                        // --- MODIFIED SECTION START ---
                        previewDescription.innerHTML = `
                            <div class="subscriber-count">${formatSubscriberCount(currentChannelDetails.subscriberCount)} subscribers</div>
                            <div class="channel-description">${currentChannelDetails.description}</div>
                        `;
                        // --- MODIFIED SECTION END ---

                        previewElement.style.display = 'block';
                    }
                } else {
                    previewElement.style.display = 'none';
                    currentChannelDetails = null;
                }
            } catch (error) {
                console.error('Error searching channel:', error);
                previewElement.style.display = 'none';
                currentChannelDetails = null;
            }
        }, 300);

        async function findChannel(query) {
            const searchUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&type=channel&q=${encodeURIComponent(query)}&key=${API_KEY}`;
            
            const response = await fetch(searchUrl);
            const data = await response.json();
            
            if (!data.items || data.items.length === 0) {
                throw new Error('No channels found matching that name.');
            }

            const channelId = data.items[0].id.channelId;
            const channelUrl = `${CHANNELS_URL}?part=snippet,contentDetails,statistics&id=${channelId}&key=${API_KEY}`;
            const channelResponse = await fetch(channelUrl);
            return await channelResponse.json();
        }

        async function getRecentVideoUrls(channelId) {
            const playlistResponse = await fetch(`${CHANNELS_URL}?part=contentDetails&id=${channelId}&key=${API_KEY}`);
            const playlistData = await playlistResponse.json();
            const uploadsPlaylistId = playlistData.items[0].contentDetails.relatedPlaylists.uploads;

            const videosResponse = await fetch(
                `${PLAYLIST_ITEMS_URL}?part=contentDetails&playlistId=${uploadsPlaylistId}&maxResults=${NUM_VIDEOS}&key=${API_KEY}`
            );
            const videosData = await videosResponse.json();

            return videosData.items.map(item => 
                `https://www.youtube.com/watch?v=${item.contentDetails.videoId}`
            );
        }

        function formatSubscriberCount(count) {
            if (count >= 1000000) {
                return (count / 1000000).toFixed(1) + 'M';
            } else if (count >= 1000) {
                return (count / 1000).toFixed(1) + 'K';
            }
            return count;
        }

        function formatNumber(count) {
            if (!count) return '0';
            return formatSubscriberCount(count);
        }

        /**
         * uploadChannelDNAs
         * * Opens a file selector that gets a CSV file of Channel IDs and channel URLs,
         * then extracts all the Creator DNAs from the list.
         **/
        async function uploadChannelDNAs() {
            document.getElementById('csvFileInput').click(); // Trigger the hidden CSV file input
        }

        // Add this function to your script to extract the channel ID from a URL
        function getChannelIdFromUrl(url) {
        const channelIdRegex = /(?:youtube\.com\/(?:c\/|channel\/|user\/|@))([^/?&]+)/;
        const match = url.match(channelIdRegex);
        if (match && match[1]) {
            const channelId = match[1];
            if (channelId.startsWith('UC')) {
            return channelId;
            }
        }
        return null;
        }

        /**
         * @function handleCsvFileSelect
         * @description Handles the selection of a CSV file, reads its content, and processes each channel.
         * Assumes CSV format: "Channel Name,Channel URL"
         */
        async function handleCsvFileSelect(event) {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = async (e) => {
                const csvContent = e.target.result;
                // Split by newlines, ignore the first line (header)
                const lines = csvContent.split('\n').slice(1).filter(line => line.trim() !== '');

                const loadingContainer = document.querySelector('.loading-container');
                const resultsContainer = document.querySelector('.channel-results');
                loadingContainer.style.display = 'flex';
                resultsContainer.innerHTML = ''; // Clear previous results

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    // Use a simple regex to handle commas inside double quotes.
                    // This is a common and reliable way to parse simple CSVs.
                    const [channelName, channelUrl] = line.match(/(?:"[^"]*"|[^,])+/g).map(s => s.replace(/"/g, '').trim());

                    if (channelName || channelU) {
                        try {
                            loadingContainer.querySelector('.loading-text').textContent = 
                                `processing channel ${i + 1} of ${lines.length}: ${channelName || channelUrl}...`;
                            await getChannelDNA(channelName, null, null, channelUrl); // Pass both
                        } catch (error) {
                            console.error(`Error processing channel ${channelName || channelUrl} from CSV:`, error);
                        }
                    }
                }
                loadingContainer.style.display = 'none';
                alert('All channels from CSV processed!');
                loadSavedChannels();
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        /**
         * @function getChannelDNA
         * @description Main function to generate and save Creator DNA.
         * @param {string|null} channelNameInput - The channel name (optional).
         * @param {object|null} initialChannelDetails - Pre-fetched channel details (optional).
         * @param {string|null} userFeedback - User feedback for regeneration (optional).
         * @param {string|null} initialChannelUrl - The channel URL (optional).
         */
        async function getChannelDNA(channelNameInput = null, initialChannelDetails = null, userFeedback = null, initialChannelUrl = null) {
            let targetChannelDetails;
            const resultsContainer = document.querySelector('.channel-results');
            const loadingContainer = document.querySelector('.loading-container');
            
            // Determine targetChannelDetails
            if (initialChannelDetails) {
                targetChannelDetails = initialChannelDetails;
    } else if (initialChannelUrl) {
        const channelId = getChannelIdFromUrl(initialChannelUrl);
        if (channelId) {
            // Found ID from URL, proceed with fetching details
            try {
                const channelDetailsUrl = `${CHANNELS_URL}?part=snippet,statistics&id=${channelId}&key=${API_KEY}`;
                const channelResponse = await fetch(channelDetailsUrl);
                const channelData = await channelResponse.json();

                if (channelData.items && channelData.items.length > 0) {
                    const channel = channelData.items[0].snippet;
                    const statistics = channelData.items[0].statistics;
                    targetChannelDetails = {
                        id: channelId,
                        name: channel.title,
                        thumbnail: channel.thumbnails.medium.url,
                        description: channel.description,
                        channelUrl: initialChannelUrl,
                        subscriberCount: statistics.subscriberCount
                    };
                } else {
                    // URL failed to return data, fall back to name search
                    console.warn('URL lookup failed, falling back to name search...');
                }
            } catch (error) {
                console.error('Error fetching channel details from URL:', error);
                console.warn('URL lookup failed, falling back to name search...');
            }
        }
    }

    // Fallback to name search if URL failed or was not provided
    if (!targetChannelDetails && channelNameInput) {
        try {
            const searchUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&type=channel&q=${encodeURIComponent(channelNameInput)}&key=${API_KEY}`;
            const searchResponse = await fetch(searchUrl);
            const searchData = await searchResponse.json();

            if (!searchData.items || searchData.items.length === 0) {
                throw new Error('No channels found matching that name.');
            }
            const channelId = searchData.items[0].id.channelId;
            const channelUrl = `https://www.youtube.com/channel/${channelId}`;

            const channelDetailsUrl = `${CHANNELS_URL}?part=snippet,statistics&id=${channelId}&key=${API_KEY}`;
            const channelResponse = await fetch(channelDetailsUrl);
            const channelData = await channelResponse.json();

            if (channelData.items && channelData.items.length > 0) {
                const channel = channelData.items[0].snippet;
                const statistics = channelData.items[0].statistics;
                targetChannelDetails = {
                    id: channelId,
                    name: channel.title,
                    thumbnail: channel.thumbnails.medium.url,
                    description: channel.description,
                    channelUrl: channelUrl,
                    subscriberCount: statistics.subscriberCount
                };
            } else {
                throw new Error('Could not retrieve channel details.');
            }
        } catch (error) {
            console.error('Error fetching channel details for DNA generation:', error);
            throw new Error(`Failed to get channel details for ${channelNameInput}: ${error.message}`);
        }
    } else if (!targetChannelDetails && !initialChannelDetails) {
        // Final fallback to global currentChannelDetails if no arguments provided
        if (!currentChannelDetails) {
            console.error('No channel selected and no initial details provided');
            return;
        }
        targetChannelDetails = currentChannelDetails;
    }

    try {
        // Display loading status (only if it's not a bulk upload from CSV, or if we want individual status)
        // For bulk uploads, the loading text is set by handleCsvFileSelect
        if (!userFeedback) {
            loadingContainer.style.display = 'flex';
            loadingContainer.querySelector('.loading-text').textContent = 'downloading transcripts...';
            resultsContainer.innerHTML = '';
        }

        const videoUrls = await getRecentVideoUrls(targetChannelDetails.id);                

        // Get channel stats (average views)
        try {
            const statsResponse = await fetch(`${window.API_BASE_URL}/api/v1/creatorDna/getChannelStats`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ channelId: targetChannelDetails.id })
            });
            
            const statsData = await statsResponse.json();
            if (statsData.success && statsData.stats) {
                targetChannelDetails.averageViews = statsData.stats.averageViews;
                targetChannelDetails.viewsTimeframe = statsData.stats.timeframe;
                console.log(`Average views for ${targetChannelDetails.name}: ${targetChannelDetails.averageViews} (${targetChannelDetails.viewsTimeframe})`);
            }
        } catch (statsError) {
            console.warn(`Error getting channel stats for ${targetChannelDetails.name}:`, statsError);
            // Continue without average views
        }

        // Get transcripts
        loadingContainer.querySelector('.loading-text').textContent = `downloading transcripts for ${targetChannelDetails.name}...`;
        const transcriptResponse = await fetch(`${window.API_BASE_URL}/api/v1/transcripts/getChannelTranscripts`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
                videoUrls,
                language: getClientLanguage()
            })
        });

        const transcriptData = await transcriptResponse.json();
        if (!transcriptData.success) {
            throw new Error(transcriptData.error);
        }

        // Prepare form data with files and transcripts
        const formData = new FormData();
        formData.append('channelName', targetChannelDetails.name);
        formData.append('transcripts', JSON.stringify(transcriptData.transcripts));
        formData.append('language', getClientLanguage());
                
        // Add selected files to form data (only for single channel manual upload/reprompt)
        if (selectedFiles.size > 0 && !initialChannelDetails && !userFeedback) { // Check if it's a new manual upload
            const fileInput = document.getElementById('fileInput');
            const fileItems = fileList.getElementsByClassName('file-item');
            for (const item of Array.from(fileItems)) {
                const fileName = item.firstElementChild.textContent;
                const fileObj = Array.from(fileInput.files).find(f => f.name === fileName);
                if (fileObj) {
                    formData.append('file', fileObj);
                }
            }
        }

        const analysisPrompt = `REVISION REQUEST: The following is a request to revise a channel's DNA analysis.

CREATOR FEEDBACK:
${userFeedback || 'No feedback provided, this is the initial analysis.'}

CURRENT DNA ANALYSIS:
${userFeedback ? JSON.stringify(initialChannelDetails.channelAnalysis, null, 2) : 'No previous analysis.'}

Please analyze the YouTube channel "${targetChannelDetails.name}" with the above feedback in mind, also considering the provided video transcripts.

Remember you MUST FOLLOW THIS EXACT JSON format for your output. Never give any commentary:
{
  "channelAnalysis": [
    {
      "sectionTitle": "CreatorDNA", //The core essence and DNA of the creator/channel, the qualities to stay true to when 'bending without breaking'
      "sectionBody": "<content>"
    },
    {
      "sectionTitle": "Creator Personality",
      "sectionBody": "<content>"
    },
    {
      "sectionTitle": "Content Style",
      "sectionBody": "<content>"
    },
    {
      "sectionTitle": "Audience Connection",
      "sectionBody": "<content>"
    },
    {
      "sectionTitle": "Channel Story",
      "sectionBody": "<content>"
    }
  ]
}`;

                formData.append('channelName', analysisPrompt); // Use prompt for analysis

                // Analyze with Gemini
                loadingContainer.querySelector('.loading-text').textContent = `analyzing channel DNA for ${targetChannelDetails.name}...`;
                
                const analysisResponse = await fetch(`${window.API_BASE_URL}/api/v1/creatorDna/analyzeChannel`, {
                    method: 'POST',
                    body: formData
                });

                const analysisData = await analysisResponse.json();
                if (!analysisData.success) {
                    throw new Error(analysisData.error);
                }

                // Save the complete DNA with channel details
                const fullDNAData = {
                    // Extract channelAnalysis from the nested analysis property
                    channelId: targetChannelDetails.id,
                    channelName: targetChannelDetails.name,
                    channelAnalysis: analysisData.analysis.channelAnalysis,
                    channelThumbnail: targetChannelDetails.thumbnail,
                    channelDescription: targetChannelDetails.description,
                    channelUrl: targetChannelDetails.channelUrl,
                    subscriberCount: targetChannelDetails.subscriberCount,
                    averageViews: targetChannelDetails.averageViews,
                    viewsTimeframe: targetChannelDetails.viewsTimeframe
                };

                await fetch(`${window.API_BASE_URL}/api/v1/creatorDna/saveCreatorDNA`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        creatorDNA: fullDNAData,
                        language: getClientLanguage()
                    })
                });

                // Clear file list after successful submission if it's a new upload
                if (!initialChannelDetails && !userFeedback) {
                    fileList.innerHTML = '';
                    selectedFiles.clear();
                }

                // Display results (if it's not a bulk upload that just processed the last item)
                if (!channelNameInput) {
                    loadingContainer.style.display = 'none';
                    displayChannelResults(fullDNAData);
                    currentChannelDetails = fullDNAData;
                }

            } catch (error) {
                console.error(`Error processing DNA for ${targetChannelDetails ? targetChannelDetails.name : 'unknown channel'}:`, error);
                if (!initialChannelDetails && !userFeedback) {
                    loadingContainer.style.display = 'none';
                    resultsContainer.innerHTML = `<p>Error: ${error.message}</p>`;
                }
                throw error; // Re-throw to indicate failure for handleCsvFileSelect
            }
        }

        async function displayChannelResults(data) {
            const resultsContainer = document.querySelector('.channel-results');
            resultsContainer.innerHTML = '';
            
            // Add channel name without link at the top
            const channelHeader = document.createElement('div');
            channelHeader.style.marginBottom = '2rem';
            
            // Format subscriber count and average views
            const subscriberCount = formatSubscriberCount(data.subscriberCount);
            const averageViews = data.averageViews ? formatSubscriberCount(data.averageViews) : null;
            
            // Create the average views label based on timeframe
            let averageViewsLabel = "Average views";
            if (data.viewsTimeframe) {
                if (data.viewsTimeframe === "past 3 months") {
                    averageViewsLabel = "Avg views/video (past 3 months)";
                } else if (data.viewsTimeframe === "5 most recent videos") {
                    averageViewsLabel = "Avg views/video (5 most recent)";
                }
            }
            
            // Create header with channel name and stats
            channelHeader.innerHTML = `
                <h2 style="font-size: 1.5rem; color: #26201F;">
                    ${data.channelName}
                </h2>
                <div style="display: flex; gap: 1rem; margin-top: 0.5rem; font-size: 0.9rem; color: #26201F;">
                    <div>${subscriberCount} subscribers</div>
                    ${averageViews ? `<div>${averageViews} ${averageViewsLabel}</div>` : ''}
                </div>
            `;
            resultsContainer.appendChild(channelHeader);
            
            // Create a container for the DNA cards
            const cardsContainer = document.createElement('div');
            cardsContainer.className = 'dna-cards-container';
            
            // Rest of the cards display
            data.channelAnalysis.forEach((section, index) => {
                const card = document.createElement('div');
                card.className = 'brand-card';
                card.style.borderColor = "#F742BD";
                card.style.marginBottom = "1rem";
                card.setAttribute('data-index', index);
                
                const title = document.createElement('h2');
                title.className = 'brand-card-title';
                title.textContent = section.sectionTitle;
                title.style.color = "#26201F";
                
                const body = document.createElement('div');
                body.className = 'brand-card-body';
                body.textContent = section.sectionBody;
                body.setAttribute('contenteditable', 'false');
                
                card.appendChild(title);
                card.appendChild(body);
                cardsContainer.appendChild(card);
            });
            
            resultsContainer.appendChild(cardsContainer);
            
            // Add buttons container
            const buttonsContainer = document.createElement('div');
            buttonsContainer.className = 'dna-buttons-container';
            buttonsContainer.innerHTML = `
                <button class="edit-dna-btn" onclick="toggleEdit(this)" data-translation-key="channel-edit-button">EDIT</button>
                <button class="reprompt-dna-btn" onclick="showRepromptOverlay()" data-translation-key="channel-reprompt-button">RE-PROMPT</button>
            `;
            
            resultsContainer.appendChild(buttonsContainer);
            await translateDynamicElements();
        }

        async function translateDynamicElements() {
            //Regular Buttons
            const buttonsContainer = document.querySelector('.dna-buttons-container');
            if(buttonsContainer){
                const elementsToTranslate = buttonsContainer.querySelectorAll('[data-translation-key]');
                for (const element of elementsToTranslate) {
                    const key = element.dataset.translationKey;
                    if (translations[key] && translations[key][window.currentLanguage]) {
                        if ((element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') && element.hasAttribute('placeholder')) {
                            element.setAttribute('placeholder', translations[key][window.currentLanguage]);
                        } else {
                            element.textContent = translations[key][window.currentLanguage];
                        }
                    }
                }
            }
            //Reprompt Overlay
            const overlay = document.getElementById('repromptOverlay');
            if(overlay){
                 const overlayElementsToTranslate = overlay.querySelectorAll('[data-translation-key]');
                for (const element of overlayElementsToTranslate) {
                    const key = element.dataset.translationKey;
                    if (translations[key] && translations[key][window.currentLanguage]) {
                        if ((element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') && element.hasAttribute('placeholder')) {
                            element.setAttribute('placeholder', translations[key][window.currentLanguage]);
                        } else {
                            element.textContent = translations[key][window.currentLanguage];
                        }
                    }
                }
            }
        }

        document.addEventListener('DOMContentLoaded', async () => {
            await translateUI();

            const dropdownArrow = document.querySelector('.dropdown-arrow');
            const dropdownMenu = document.getElementById('channelsDropdown');
            
            dropdownArrow.addEventListener('click', async (e) => {
                e.stopPropagation();
                dropdownMenu.classList.toggle('active');
                if (dropdownMenu.classList.contains('active')) {
                    await loadSavedChannels();
                }
            });

            document.addEventListener('click', (e) => {
                if (!dropdownMenu.contains(e.target) && !dropdownArrow.contains(e.target)) {
                    dropdownMenu.classList.remove('active');
                }
            });
        });

        async function loadSavedChannels() {
            try {
                // Use query parameter for language in GET request
                const language = getClientLanguage();
                const response = await fetch(`${window.API_BASE_URL}/api/v1/creatorDna/getCreatorDNAs?language=${encodeURIComponent(language)}`);
                const channels = await response.json();

                const dropdownMenu = document.getElementById('channelsDropdown');
                dropdownMenu.innerHTML = '';

                // Expected 'channels' as an array from the server.
                if (Array.isArray(channels)) {
                    channels.sort((a, b) => a.channelName.localeCompare(b.channelName)); // Sort the array
                    channels.forEach(channelData => { // Iterate over array elements

                        const item = document.createElement('div');
                        item.className = 'dropdown-item';
                        
                        const nameSpan = document.createElement('span');
                        nameSpan.textContent = channelData.channelName;
                        
                        const deleteIcon = document.createElement('img');
                        deleteIcon.src = '/icons/delete.svg';
                        deleteIcon.alt = 'Delete Channel';
                        deleteIcon.className = 'delete-icon-svg';

                        // Pass channelData.channelName for deletion
                        deleteIcon.addEventListener('click', (e) => deleteChannelDNA(channelData.channelName, e));

                        item.appendChild(nameSpan);
                        item.appendChild(deleteIcon);

                        item.addEventListener('click', () => loadChannelDNA(channelData));
                        
                        dropdownMenu.appendChild(item);
                    });
            } else {
                console.error('Error: Expected an array of channels, but received:', channels);
                dropdownMenu.innerHTML = '<div class="dropdown-item">Error loading channels</div>';
            }
            } catch (error) {
                console.error('Error loading saved channels:', error);
            }
        }

        async function deleteChannelDNA(channelName, event) {
            event.stopPropagation();
            try {
                // Properly encode the channel name for the URL
                const encodedChannelName = encodeURIComponent(channelName);
                console.log('Deleting channel:', channelName);
                console.log('Encoded channel name:', encodedChannelName);
                
                // Use query parameter for language in DELETE request
                const language = getClientLanguage();
                const response = await fetch(`${window.API_BASE_URL}/api/v1/creatorDna/deleteCreatorDNA/${encodedChannelName}?language=${encodeURIComponent(language)}`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Server response:', errorText);
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                await loadSavedChannels();
            } catch (error) {
                console.error('Error deleting channel:', error);
                alert(`Failed to delete channel: ${error.message}`);
            }
        }

        function loadChannelDNA(channelData) {
            // Update the preview card with saved data
            const previewImage = document.getElementById('preview-thumbnail');
            const previewTitle = document.getElementById('preview-title');
            const previewDescription = document.getElementById('preview-description');
            const previewElement = document.getElementById('channel-preview');
            
            previewImage.src = `/proxy-image?url=${encodeURIComponent(channelData.channelThumbnail)}`;

            // Update title with channel link
            previewTitle.innerHTML = `
                <a href="${channelData.channelUrl}" target="_blank" class="channel-link">
                    <span id="preview-name">${channelData.channelName}</span>
                    <span class="arrow">↗</span>
                    <span class="underline"></span>
                </a>
            `;
            
            // Format subscriber count and average views
            const subscriberCount = formatSubscriberCount(channelData.subscriberCount);
            const averageViews = channelData.averageViews ? formatSubscriberCount(channelData.averageViews) : null;
            
            // Create the average views label based on timeframe
            let averageViewsLabel = "Average views";
            if (channelData.viewsTimeframe) {
                if (channelData.viewsTimeframe === "past 3 months") {
                    averageViewsLabel = "Avg views/video (past 3 months)";
                } else if (channelData.viewsTimeframe === "5 most recent videos") {
                    averageViewsLabel = "Avg views/video (5 most recent)";
                }
            }
            
            // Update description with subscriber count and average views
            previewDescription.innerHTML = `
                <div class="subscriber-count">${subscriberCount} subscribers</div>
                ${averageViews ? `<div class="subscriber-count">${averageViews} ${averageViewsLabel}</div>` : ''}
                <div class="channel-description">${channelData.channelDescription}</div>
            `;
            
            previewElement.style.display = 'block';
            
            // Store the channel details
            currentChannelDetails = {
                id: channelData.channelId, // Ensure ID is stored
                name: channelData.channelName,
                thumbnail: channelData.channelThumbnail,
                description: channelData.channelDescription,
                channelUrl: channelData.channelUrl,
                subscriberCount: channelData.subscriberCount,
                averageViews: channelData.averageViews,
                viewsTimeframe: channelData.viewsTimeframe,
                channelAnalysis: channelData.channelAnalysis // Include channelAnalysis for reprompting
            };
            
            document.querySelector('.brand-input').value = channelData.channelName;
            document.getElementById('channelsDropdown').classList.remove('active');
            
            // Display the analysis
            displayChannelResults(channelData);
        }

        async function toggleEdit(button) {
            const resultsContainer = document.querySelector('.channel-results');
            const cardBodies = resultsContainer.querySelectorAll('.brand-card-body');

             let buttonText = button.textContent.toUpperCase().trim(); // Normalize for comparison

            if (buttonText === 'EDIT' || buttonText === 'EDITAR') {
                // Enable editing
                cardBodies.forEach(body => {
                    body.setAttribute('contenteditable', 'true');
                    body.classList.add('editing');
                });
                button.textContent = window.currentLanguage === 'spanish' ? 'GUARDAR' : 'SAVE';
            } else {
                 // Save changes
                const updatedDNA = await saveChanges();
                if (updatedDNA) {
                    // Disable editing
                    cardBodies.forEach(body => {
                        body.setAttribute('contenteditable', 'false');
                        body.classList.remove('editing');
                    });
                    await displayChannelResults(updatedDNA); // Await the display
                }
            }
        }

async function saveChanges() {
    try {
        const resultsContainer = document.querySelector('.channel-results');
        const cardBodies = resultsContainer.querySelectorAll('.brand-card-body');
        const cards = Array.from(cardBodies).map((body, index) => ({
            sectionTitle: body.parentElement.querySelector('.brand-card-title').textContent,
            sectionBody: body.textContent
        }));

        // Get current channel details
        const channelName = document.querySelector('.channel-results h2').textContent.trim();
        
        // Create updated DNA data
        const updatedDNA = {
            channelId: currentChannelDetails.id, // Ensure ID is included
            channelName: channelName,
            channelThumbnail: currentChannelDetails.thumbnail,
            channelDescription: currentChannelDetails.description,
            channelUrl: currentChannelDetails.channelUrl,
            subscriberCount: currentChannelDetails.subscriberCount,
            averageViews: currentChannelDetails.averageViews,
            viewsTimeframe: currentChannelDetails.viewsTimeframe,
            channelAnalysis: cards
        };

        // Save to server
        const response = await fetch(`${window.API_BASE_URL}/api/v1/creatorDna/saveCreatorDNA`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                creatorDNA: updatedDNA,
                language: getClientLanguage()
            })
        });

        if (!response.ok) {
            throw new Error('Failed to save changes');
        }
        
        // Update global currentChannelDetails after saving
        currentChannelDetails = updatedDNA;

        return updatedDNA;
    } catch (error) {
        console.error('Error saving changes:', error);
        alert('Failed to save changes. Please try again.');
        return null;
    }
}

function showRepromptOverlay() {
        const overlay = document.getElementById('repromptOverlay');
        overlay.innerHTML = `
            <div class="overlay-content">
                <h3 class="overlay-title" data-translation-key="channel-reprompt-title">What would you like to adjust about the DNA?</h3>
                <textarea class="feedback-textarea" placeholder="Enter your feedback here..." data-translation-key="channel-reprompt-placeholder"></textarea>
                <div class="overlay-buttons">
                    <button class="get-dna-btn" onclick="cancelReprompt()" data-translation-key="channel-reprompt-cancel-button">CANCEL</button>
                    <button class="get-dna-btn" onclick="regenerateDNA()" data-translation-key="channel-reprompt-regenerate-button">REGENERATE DNA</button>
                </div>
            </div>
        `;
         translateDynamicElements();
        overlay.style.display = 'flex';
    }

function cancelReprompt() {
    document.getElementById('repromptOverlay').style.display = 'none';
    document.querySelector('.feedback-textarea').value = '';
}

async function regenerateDNA() {
    const userFeedback = document.querySelector('.feedback-textarea').value.trim();
    const loadingContainer = document.querySelector('.loading-container');
    const resultsContainer = document.querySelector('.channel-results');
    
    try {
        // Show loading state
        loadingContainer.style.display = 'flex';
        loadingContainer.querySelector('.loading-text').textContent = 'downloading transcripts...';
        resultsContainer.innerHTML = '';

        // Use currentChannelDetails for regeneration
        if (!currentChannelDetails || !currentChannelDetails.id) {
            throw new Error('No channel details available for regeneration.');
        }

        // Get recent video URLs
        const videoUrls = await getRecentVideoUrls(currentChannelDetails.id);
        
        // Get channel stats (average views)
        try {
            const statsResponse = await fetch(`${window.API_BASE_URL}/api/v1/creatorDna/getChannelStats`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ channelId: currentChannelDetails.id })
            });
            
            const statsData = await statsResponse.json();
            if (statsData.success && statsData.stats) {
                currentChannelDetails.averageViews = statsData.stats.averageViews;
                currentChannelDetails.viewsTimeframe = statsData.stats.timeframe;
                console.log(`Average views for ${currentChannelDetails.name}: ${currentChannelDetails.averageViews} (${currentChannelDetails.viewsTimeframe})`);
            }
        } catch (statsError) {
            console.warn(`Error getting channel stats for ${currentChannelDetails.name}:`, statsError);
            // Continue without average views
        }

        // Get transcripts
        loadingContainer.querySelector('.loading-text').textContent = `downloading transcripts for ${currentChannelDetails.name}...`;
        const transcriptResponse = await fetch(`${window.API_BASE_URL}/api/v1/transcripts/getChannelTranscripts`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
                videoUrls,
                language: getClientLanguage() 
            })
        });

        const transcriptData = await transcriptResponse.json();
        if (!transcriptData.success) {
            throw new Error(transcriptData.error);
        }

        // Create the analysis prompt
        const analysisPrompt = `REVISION REQUEST: The following is a request to revise a channel's DNA analysis.

CREATOR FEEDBACK:
${userFeedback}

CURRENT DNA ANALYSIS:
${JSON.stringify(currentChannelDetails.channelAnalysis, null, 2)}

Please analyze the YouTube channel "${currentChannelDetails.name}" with the above feedback in mind, also considering the provided video transcripts.

Remember you MUST FOLLOW THIS EXACT JSON format for your output. Never give any commentary:
{
  "channelAnalysis": [
    {
      "sectionTitle": "CreatorDNA", //The core essence and DNA of the creator/channel, the qualities to stay true to when 'bending without breaking'
      "sectionBody": "<content>"
    },
    {
      "sectionTitle": "Creator Personality",
      "sectionBody": "<content>"
    },
    {
      "sectionTitle": "Content Style",
      "sectionBody": "<content>"
    },
    {
      "sectionTitle": "Audience Connection",
      "sectionBody": "<content>"
    },
    {
      "sectionTitle": "Channel Story",
      "sectionBody": "<content>"
    }
  ]
}`;

        // Prepare form data
        const formData = new FormData();
        formData.append('channelName', analysisPrompt); // Send prompt for analysis
        formData.append('transcripts', JSON.stringify(transcriptData.transcripts));
        formData.append('language', getClientLanguage());

        // Analyze with Gemini
        loadingContainer.querySelector('.loading-text').textContent = `analyzing channel DNA for ${currentChannelDetails.name}...`;
        
        const analysisResponse = await fetch(`${window.API_BASE_URL}/api/v1/creatorDna/analyzeChannel`, {
            method: 'POST',
            body: formData
        });

        const analysisData = await analysisResponse.json();
        if (!analysisData.success) {
            throw new Error(analysisData.error);
        }

        // Create the full DNA data with the original channel name
        const fullDNAData = {
            channelId: currentChannelDetails.id,
            channelName: currentChannelDetails.name,
            channelAnalysis: analysisData.analysis.channelAnalysis,
            channelThumbnail: currentChannelDetails.thumbnail,
            channelDescription: currentChannelDetails.description,
            channelUrl: currentChannelDetails.channelUrl,
            subscriberCount: currentChannelDetails.subscriberCount,
            averageViews: currentChannelDetails.averageViews,
            viewsTimeframe: currentChannelDetails.viewsTimeframe
        };

        // Save the DNA
        await fetch(`${window.API_BASE_URL}/api/v1/creatorDna/saveCreatorDNA`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                creatorDNA: fullDNAData,
                language: getClientLanguage()
            })
        });

        // Hide overlay and loading
        cancelReprompt();
        loadingContainer.style.display = 'none';

        // Display results
        displayChannelResults(fullDNAData);
        currentChannelDetails = fullDNAData; // Update global after successful regeneration
    } catch (error) {
        console.error('Error regenerating DNA:', error);
            loadingContainer.style.display = 'none';
            resultsContainer.innerHTML = `<p>Error: ${error.message}</p>`;
    }
}
    </script>
</body>
</html>
